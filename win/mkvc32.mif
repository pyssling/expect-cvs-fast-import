#==============================================================================
#
#   Make information file for the Microsoft Visual C++ 32-bit tools.
#
#
#   NMAKE specific syntax is allowed in this file.
#
#==============================================================================
# RCS: @(#) $Id: mkvc32.mif,v 1.1.2.4 2001/10/11 03:59:36 davygrvy Exp $
#==============================================================================

!ifndef _MKVC32_MIF
_MKVC32_MIF = 1

!include ..\mkconfig.mif


TOOLSET	    = vc32

rc32	    = $(RC)
cc32	    = $(CC)
link32	    = link
lib32	    = lib
cvtres32    = cvtres

!ifndef OUT_DIR
OUT_DIR	    = $(TMP_DIR)
!endif

!if !defined(DEBUG)
DEBUG		= 0
NODEBUG		= 1
!elseif $(DEBUG) == 1
!undef NODEBUG
!else
NODEBUG		= 1
!endif

!ifndef STATIC_BUILD
STATIC_BUILD	= 0
!endif

!ifndef USE_TCL_STUBS
USE_TCL_STUBS	= 1
!endif

# Set NOMSVCRT to 1 to use libcmt(d).lib instead of the
# dynamic run-time.
#
!ifndef NOMSVCRT
!if $(STATIC_BUILD)
NOMSVCRT	= 1
!else
NOMSVCRT	= 0
!endif
!endif

!if $(STATIC_BUILD) == 0 && $(NOMSVCRT) == 1
!error The static runtime in a loadable (dll) extension is a useless configuration that will cause abnormal and unnecessary code bloat.
!endif

!if $(DEBUG)
TMPDIRNAMEPREFIX = Debug
DBGX = d
!else
TMPDIRNAMEPREFIX = Release
DBGX =
!endif

TMPDIRNAME	=

!if $(STATIC_BUILD)
!if $(NOMSVCRT) == 0
TMPDIRNAME = $(TMPDIRNAMEPREFIX)_StaticX
STCX	= x
!else
TMPDIRNAME = $(TMPDIRNAMEPREFIX)_Static
STCX	= s
!endif
OUTEXT	= lib
!else
STCX	=
OUTEXT	= dll
!endif

!if "$(TMPDIRNAME)" == ""
TMPDIRNAME	= $(TMPDIRNAMEPREFIX)
!endif

SOURCEROOT	= ..
COMPATDIR	= $(SOURCEROOT)\compat
GENERICDIR	= $(SOURCEROOT)\generic
TESTDIR		= $(SOURCEROOT)\tests
TOOLSDIR	= $(SOURCEROOT)\tools
WINDIR		= $(SOURCEROOT)\win
TMP_DIR		= $(WINDIR)\$(TMPDIRNAME)

!ifndef OUT_DIR
OUT_DIR		= $(WINDIR)\$(TMPDIRNAME)
!endif

# Is TCLROOT pointing to the sources or the install ?
#
!if $(ISTCLINSTALL)
TCLSTUBSLIB	= "$(TCLROOT)\lib\tclstub$(TCLMAJOR)$(TCLMINOR).lib"
TCLLIB		= "$(TCLROOT)\lib\tcl$(TCLMAJOR)$(TCLMINOR).lib"
TCLSH_PROG	= "$(TCLROOT)\bin\tclsh$(TCLMAJOR)$(TCLMINOR).exe"
!else
TCLSTUBSLIB	= "$(TCLROOT)\win\$(TMPDIRNAMEPREFIX)\tclstub$(TCLMAJOR)$(TCLMINOR)$(DBGX).lib"
TCLLIB		= "$(TCLROOT)\win\$(TMPDIRNAMEPREFIX)\tcl$(TCLMAJOR)$(TCLMINOR)$(DBGX).lib"
TCLSH_PROG	= "$(TCLROOT)\win\$(TMPDIRNAMEPREFIX)\tclsh$(TCLMAJOR)$(TCLMINOR)$(DBGX).exe"
!endif

!if $(ISTCLINSTALL)
TCL_INCLUDES	= -I"$(TCLROOT)\include"
TCL_INTINCLUDES	= -I"$(TCLROOT)\include"
!else
TCL_INCLUDES	= -I"$(TCLROOT)\generic"
TCL_INTINCLUDES	= -I"$(TCLROOT)\generic" -I"$(TCLROOT)\win"
!endif

#==============================================
# Test for compiler features
#==============================================

### Win95 doesn't support "2>&1".
### Anyone got a work-around?

!if [ $(cc32) -c -Zs -TC nul 2>&1 | find "(R)" ] == 0

!if [ $(cc32) -nologo -ZI -c -Zs -TC -Fdtemp nul 2>&1 | find /c "D4002" > nul ] != 0
!message +++ compiler has `edit and continue`
!else
!message +++ compiler doesn't have `edit and continue`
!endif

!if [ $(cc32) -nologo -Ox -c -Zs -TC -Fdtemp nul 2>&1 | find /c "D4002" > nul ] != 0
!message +++ compiler has `optimizations`
COPTS	= -Ox
!else
!message +++ compiler doesn't have `optimizations`
COPTS	=
!endif

### Force a chariage return.
!if [ echo. ] != 0
!endif

### Clean-up temp files after tests.
!if [ @for %d in (temp.idb temp.pdb) do @if exist %d erase %d ] != 0
!endif

CFLAGS	= -nologo -c $(COPTS) -MD$(DBGX) -YX -Fo$(TMP_DIR)^\ -Fp$(TMP_DIR)^\

!else
!error "$(cc32)" is STILL not available in the path.
!endif

#==============================================
# a bug fix needed for VC++ 6.0's nmake tool.
#
# Reset the version *string* back to the integer
# it's supposed to be.  More entries will have
# to be made here for all subsiquent nmake
# releases until Microsoft fixes it.
#
# Please log your displeasure with their product
# by sending an email to blackhole@microsoft.com
#
_NMAKE_VER  = $(_NMAKE_VER:6.00.8168.0=600)
#==============================================


# Win95 doesn't support "&" on command line.
#MkDest=@for %d in ($(PLATFORM) $(ObjDir)) do $(COMSPEC) /c if not exist %d md %d

#clean:
# $(MkDest)
#!if "$(OS)" == "Windows_NT"
# del /q $(ObjDir)\*.obj \
#        $(ObjDir)\*.out \
#        $(ObjDir)\*.h   \
#        $(ObjDir)\*.dbg \
#        $(ObjDir)\*.ocx \
#        $(ObjDir)\*.log \
#        $(ObjDir)\*.lib \
#        $(ObjDir)\*.exe \
#        $(ObjDir)\*.dll \
#        $(ObjDir)\*.map \
#        $(ObjDir)\*.res \
#        $(ObjDir)\*.bin \
#        $(ObjDir)\*.lst \
#        $(ObjDir)\*.blt \
#        $(ObjDir)\*.hlp \
#        $(ObjDir)\*.srl \
#        $(ObjDir)\*.exp >NUL 2>NUL
#!else  # Win95 doesn't support "2>" on command line, multiple files on a Del command, or /q
# erase  $(ObjDir)\*.obj >NUL
# erase  $(ObjDir)\*.out >NUL
# erase  $(ObjDir)\*.h   >NUL
# erase  $(ObjDir)\*.dbg >NUL
# erase  $(ObjDir)\*.ocx >NUL
# erase  $(ObjDir)\*.log >NUL
# erase  $(ObjDir)\*.lib >NUL
# erase  $(ObjDir)\*.exe >NUL
# erase  $(ObjDir)\*.dll >NUL
# erase  $(ObjDir)\*.map >NUL
# erase  $(ObjDir)\*.res >NUL
# erase  $(ObjDir)\*.bin >NUL
# erase  $(ObjDir)\*.lst >NUL
# erase  $(ObjDir)\*.blt >NUL
# erase  $(ObjDir)\*.hlp >NUL
# erase  $(ObjDir)\*.srl >NUL
# erase  $(ObjDir)\*.exp >NUL
#!endif  # OS == Windows_NT

!endif  # _MKVC32_MIF